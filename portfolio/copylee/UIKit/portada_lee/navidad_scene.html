
<!DOCTYPE html><html lang='en' class=''>
<head><script src='//production-assets.codepen.io/assets/editor/live/console_runner-079c09a0e3b9ff743e39ee2d5637b9216b3545af0de366d4b9aad9dc87e26bfd.js'></script><script src='//production-assets.codepen.io/assets/editor/live/events_runner-73716630c22bbc8cff4bd0f07b135f00a0bdc5d14629260c3ec49e5606f98fdd.js'></script><script src='//production-assets.codepen.io/assets/editor/live/css_live_reload_init-2c0dc5167d60a5af3ee189d570b1835129687ea2a61bee3513dee3a50c115a77.js'></script><meta charset='UTF-8'><meta name="robots" content="noindex"><link rel="shortcut icon" type="image/x-icon" href="//production-assets.codepen.io/assets/favicon/favicon-8ea04875e70c4b0bb41da869e81236e54394d63638a1ef12fa558a4a835f1164.ico" /><link rel="mask-icon" type="" href="//production-assets.codepen.io/assets/favicon/logo-pin-f2d2b6d2c61838f7e76325261b7195c27224080bc099486ddd6dccb469b8e8e6.svg" color="#111" /><link rel="canonical" href="https://codepen.io/matikbird/pen/NXdwqb?editors=0010" />


<style class="cp-pen-styles">html, body, canvas {
  cursor: none;
  margin: 0;
  width: 100%;
  height: 100%;
  display: block;
  position: absolute;
  top: 0;
  left: 0;
}</style></head><body>

<script src='http://production-assets.codepen.io/assets/common/stopExecutionOnTimeout-b2a7b3fe212eaa732349046d8416e00a9dec26eb7fd347590fbced3ab38af52e.js'></script><script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/r79/three.min.js'></script><script src='https://threejs.org/examples/js/controls/OrbitControls.js'></script>
<script>/*
function addNote(color) {
var gmoyerImg = document.createElement('img');
  gmoyerImg.setAttribute("id","gmoyerImg");
//var css = '.gmoyerImg:hover{width: 110px; height: 110px }';
//document.cssText = css
gmoyerImg.style.position = 'absolute';
//text2.style.zIndex = 1;    // if you still don't see the label, try uncommenting this
gmoyerImg.style.width = 100;
gmoyerImg.style.height = 100;
gmoyerImg.setAttribute('src', "https://s3-us-west-2.amazonaws.com/s.cdpn.io/783666/profile/profile-80_8.jpg")
gmoyerImg.style.borderRadius = 50 + "%";
gmoyerImg.style.bottom = 10 + 'px';
gmoyerImg.style.right = 10 + 'px';
  function gmoyerPage() {
    //document.location.href = "https://codepen.io/gmoyer";
    window.open("https://codepen.io/gmoyer")
  }
gmoyerImg.addEventListener("click", gmoyerPage)

document.body.appendChild(gmoyerImg);
  //addName(color)
}
*/
function addNote(shade) {
  var style = "#gm-signature{font-family:Helvetica,Arial,sans-serif;display:block;position:fixed;z-index:99999;bottom:2rem;right:1rem;line-height:50px;border-radius:2px;color:#444;text-transform:uppercase;font-weight:700;font-size:10px;-webkit-animation:gm-signature-in 500ms cubic-bezier(0,1.2,1,1);animation:gm-signature-in 500ms cubic-bezier(0,1.2,1,1);opacity:.6}#gm-signature strong{position:absolute;right:50%;width:200px;text-align:right;padding-right:8px;opacity:0;-webkit-transition:right 200ms,opacity 200ms;transition:right 200ms,opacity 200ms;z-index:-1;pointer-events:none}#gm-signature:hover{opacity:1}#gm-signature:hover strong{opacity:1;right:100%}#gm-signature .fill-1{fill:#fff}#gm-signature .fill-2,#gm-signature.gm-signature-light .fill-1{fill:#000}#gm-signature.gm-signature-light strong{color:#fff;text-shadow:1px 1px 0 rgba(0,0,0,.1)}#gm-signature.gm-signature-light .fill-2{fill:#fff}#gm-signature a{text-decoration:none;color:#444!important;height:20px;display:block;padding:4px}#gm-signature img{border-radius:50%}#gm-signature img,#gm-signature svg{vertical-align:middle}#gm-signature .codepen-logo,#gm-signature img{width:50px;height:50px}#gm-signature @-webkit-keyframes gm-signature-in{from{-webkit-transform:translateX(2rem);transform:translateX(2rem);opacity:0}to{-webkit-transform:translateX(0);transform:translateX(0);opacity:.6}}@keyframes gm-signature-in{from{-webkit-transform:translateX(2rem);transform:translateX(2rem);opacity:0}to{-webkit-transform:translateX(0);transform:translateX(0);opacity:.6}}";

var signature = "<a href=http:\/\/codepen.io\/gmoyer target=blank title=\"gmoyer on CodePen\"><strong>Griffin Moyer<\/strong> <img src=https://s3-us-west-2.amazonaws.com/s.cdpn.io/783666/profile/profile-512.jpg height=100 width=\"100\">"
var _container, _signature, _style;
  if (!shade) {
    shade = "light"
  }
  if (shade == "dark") {
    shade = ""
  } else {
    shade = "light"
  }
  _style = document.createElement("style");
  _style.innerHTML = style;
  _signature = document.createElement("div");
  _signature.setAttribute("id", "gm-signature");
  _signature.className = "gm-signature-" + shade;
  _signature.innerHTML = signature;
  _container = document.createElement("div");
  _container.appendChild(_signature);
  document.body.appendChild(_style);
  document.body.appendChild(_container);
  return true
}
//addNote("dark")
/*
function addName(color) {
var gmoyer = document.createElement('div');
gmoyer.setAttribute("id","gmoyerName");
gmoyer.style.position = 'absolute';
//text2.style.zIndex = 1;    // if you still don't see the label, try uncommenting this
gmoyer.style.width = 100;
gmoyer.style.height = 100;
gmoyer.style.color = color;
gmoyer.innerHTML = "gmoyer";
gmoyer.style.bottom = 10 + 'px';
gmoyer.style.right = 10 + 'px';
document.body.appendChild(gmoyer);
}
*/
</script>
<script >var scene = new THREE.Scene();
var lighterScene = new THREE.Scene()
var lighterLight = new THREE.AmbientLight( 0xffffff, 0.2 )
lighterScene.add( lighterLight )
scene.background = new THREE.Color( '#404040' );
lighterScene.background = new THREE.Color( '#404040' );
			var camera = new THREE.PerspectiveCamera( 45, window.innerWidth/window.innerHeight, 0.1, 1000 );

			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
renderer.shadowMapEnabled = true;
renderer.shadowMapType = THREE.PCFSoftShadowMap;
renderer.autoClear = false;

//dat.gui:
/*
var Controls = function() {
    this.roomlight = 0
	};

	var control = new Controls(),
		gui = new dat.GUI();
    
    gui.add(control, 'roomlight', 0, 100).name('Room Lighting')
*/
      //Create elements here:
function deg(i) {
  return i * Math.PI / 180
}
function rotateAround(point, center, angle) {
  angle = (angle) * (Math.PI/180); // Convert to radians
var rotatedX = Math.cos(angle) * (point.x - center.x) - Math.sin(angle) * (point.y-center.y) + center.x;
var rotatedY = Math.sin(angle) * (point.x - center.x) + Math.cos(angle) * (point.y - center.y) + center.y;
  return {x: rotatedX, y: rotatedY}
}
//prisim geometry
PrismGeometry = function ( vertices, height ) {

    var Shape = new THREE.Shape();

    ( function f( ctx ) {

        ctx.moveTo( vertices[0].x, vertices[0].y );
        for (var i=1; i < vertices.length; i++) {if (window.CP.shouldStopExecution(1)){break;}
            ctx.lineTo( vertices[i].x, vertices[i].y );
        }
window.CP.exitedLoop(1);

        ctx.lineTo( vertices[0].x, vertices[0].y );

    } )( Shape );

    var settings = { };
    settings.amount = height;
    settings.bevelEnabled = false;
    THREE.ExtrudeGeometry.call( this, Shape, settings );

};

PrismGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );

var oControls = new THREE.OrbitControls(camera, renderer.domElement);
function RGB(r, g, b) {
  return 'rgb(' + r + ',' + g + ',' + b + ')'
}
function randint(min, max) {
  return Math.floor(Math.random() * max) + min
}
function rotateAround(point, center, angle) {
  angle = (angle) * (Math.PI/180); // Convert to radians
var rotatedX = Math.cos(angle) * (point.x - center.x) - Math.sin(angle) * (point.y-center.y) + center.x;
var rotatedY = Math.sin(angle) * (point.x - center.x) + Math.cos(angle) * (point.y - center.y) + center.y;
  return {x: rotatedX, y: rotatedY}
}

var walls = []
var wallcolor = 'white'
function newWall(x, y, z, sx, sy, sz, sceneC) {
  gr = {}
  gr.geometry = new THREE.BoxGeometry( sx, sy, sz );
  gr.material = new THREE.MeshPhongMaterial( {color: wallcolor} );
gr.mesh = new THREE.Mesh( gr.geometry, gr.material );
  if (sceneC == 'lighter') {
    lighterScene.add(gr.mesh)
  } else {
scene.add( gr.mesh );
  }
  gr.mesh.position.set(x, y, z)
  gr.mesh.receiveShadow = true;
  gr.mesh.castShadow = true;
  return gr
}
function newPrisim(points, height, position, sceneC) {
  gr = {}
  gr.geometry = new PrismGeometry( points, height ); 

gr.material = new THREE.MeshPhongMaterial( { color: wallcolor} );

gr.mesh = new THREE.Mesh( gr.geometry, gr.material );
gr.mesh.rotation.y = -Math.PI  /  2;
if (sceneC == 'lighter') {
    lighterScene.add(gr.mesh)
  } else {
scene.add(gr.mesh);
  }
  gr.mesh.position.set(position.x, position.y, position.z)
  return gr
}
var roomsize = 200
var roomoffset = {}
  roomoffset.x = 60
  roomoffset.z = 65
walls.push(newWall(roomoffset.x, 0, roomoffset.z, 
                   roomsize, 1, roomsize))

walls.push(newWall(roomoffset.x, roomsize / 4, roomoffset.z + (roomsize / 2),
                   roomsize, roomsize, 1))

walls.push(newWall(roomoffset.x, roomsize / 4, roomoffset.z- (roomsize / 2),
                   roomsize, roomsize, 1))

walls.push(newWall(roomoffset.x + (roomsize / 2), roomsize / 4, roomoffset.z,
                   1, roomsize, roomsize))
//last wall with window:
walls.push(newWall(roomoffset.x - (roomsize / 2), -10, roomoffset.z,
                   1, roomsize / 2, roomsize))
walls.push(newWall(roomoffset.x - (roomsize / 2), roomsize / 2 + 10, roomoffset.z,
                   1, roomsize / 2, roomsize))
walls.push(newWall(roomoffset.x - (roomsize / 2), roomsize / 4, roomoffset.z + (roomsize / 2) - 20,
                   1, roomsize, roomsize))
walls.push(newWall(roomoffset.x - (roomsize / 2), roomsize / 4, roomoffset.z - (roomsize / 1.5) - 20,
                   1, roomsize, roomsize))
//window panes:
walls.push(newWall(roomoffset.x - (roomsize / 2), 0, 28,
                   1, 200, 1))
walls.push(newWall(roomoffset.x - (roomsize / 2), 50, 0,
                   1, 1, 100))
//fireplace:
wallcolor = 'brown'
walls.push(newWall(roomoffset.x - (roomsize / 2) + 10, 0, 50,
                   20, 50, 10))
walls.push(newWall(roomoffset.x - (roomsize / 2) + 10, 0, 80,
                   20, 50, 10))
walls.push(newWall(roomoffset.x - (roomsize / 2) + 10, roomsize, 65,
                   20, roomsize + (65 * 2), 10))
//adding prisim:
var A = new THREE.Vector2( 20, -10 );
var B = new THREE.Vector2( -20, -10 );
var C = new THREE.Vector2( -7.5, 10 );
var D = new THREE.Vector2( 7.5, 10 );
var position = {x: roomoffset.x - (roomsize / 2) + 20, y: 35, z: 65}
walls.push(newPrisim([A, B, C, D], 20, position))
//lighting and fog:
var lightbulb = new THREE.SpotLight('white', 1, 200, 1.5, 0.05);
lightbulb.position.set( roomoffset.x, roomsize / 2, roomoffset.z );
scene.add(lightbulb);
lightbulb.intensity = 0
//scene.fog = new THREE.Fog(0xF4F4F6, roomsize + 100, roomsize + 200);
scene.add( new THREE.AmbientLight( 0xffffff, 0.05 ) )
var nlc = 0 //next light change
var firelight;
    firelight = new THREE.PointLight(0xffff00, 1, 20);
firelight.position.set( roomoffset.x - (roomsize / 2) + 10, 10, 65 )
scene.add(firelight);
var light = new THREE.SpotLight('yellow', 1, 200, 1.5, 0.05);
  var spotTarget = new THREE.Object3D();
  scene.add(spotTarget)
  spotTarget.position.set(0, 0, 65);
  light.target = spotTarget;
  lightbulb.target = spotTarget
light.position.set( roomoffset.x - (roomsize / 2) + 20, 10, 65 )
scene.add(light);
function lightShadow(l) {
l.castShadow = true;
    l.shadowCameraVisible = true;

    l.shadowMapWidth = 5000;
    l.shadowMapHeight = 5000;

    var d = 500;

    l.shadowCameraLeft = -d;
    l.shadowCameraRight = d;
    l.shadowCameraTop = d;
    l.shadowCameraBottom = -d;

    l.shadowCameraFar = 10000;
    l.shadowDarkness = 1;
  return l
}
light = lightShadow(light)
lightbulb = lightShadow(lightbulb)
function newFire() {
  gr = {}
  gr.x = randint(-10, 15) + roomoffset.x - (roomsize / 2) + 10
  gr.y = 0
  gr.z = randint(-4, 9) + 65
  gr.size = 7
  //gr.geometry = new THREE.SphereGeometry( gr.size, 2, 3 );
  gr.geometry = new THREE.CircleGeometry( gr.size, 3 );
  gr.material = new THREE.MeshBasicMaterial( {color: RGB(255, randint(0, 255), 0),transparent: true,opacity:0.9} );
  gr.sphere = new THREE.Mesh( gr.geometry, gr.material );
  scene.add( gr.sphere );
  gr.sphere.position.x = gr.x
  gr.sphere.position.y = gr.y
  gr.sphere.position.z = gr.z
  gr.sphere.rotation.y = deg(90)
  gr.sphere.rotation.x = deg(90)
  gr.scaleD = -0.01
  return gr
}
var fire = []
for (var i = 0; i < 20; i++) {if (window.CP.shouldStopExecution(2)){break;}
  fire.push(newFire())
}
window.CP.exitedLoop(2);

function newWood(rotation) {
  gr = {}
  gr.x = 3
  gr.y = 2
  gr.z = 0
  point = {x: gr.x, y: gr.z}
  center = {x: 0, y: 0}
  r = rotateAround(point, center, rotation)
  gr.x = r.x
  gr.z = r.y
  gr.geometry = new THREE.CylinderGeometry( 1.5, 1.5, 10, 7 );
  gr.material = new THREE.MeshLambertMaterial( {color: '#651a1a'} ); //or MeshBasicMaterial
  gr.cylinder = new THREE.Mesh( gr.geometry, gr.material );
  gr.cylinder.position.x = gr.x + roomoffset.x - (roomsize / 2) + 10
  gr.cylinder.position.y = gr.y
  gr.cylinder.position.z = gr.z + 65
  gr.cylinder.rotation.x = 0
  gr.cylinder.rotation.y = -deg(rotation)
  gr.cylinder.rotation.z = deg(90)
  scene.add( gr.cylinder );
  return gr
}
var wood = []
var woodCount = 10
for (var i = 0; i < woodCount; i++) {if (window.CP.shouldStopExecution(3)){break;}
  wood.push(newWood(i * (360 / woodCount)))
}
window.CP.exitedLoop(3);

function newTree() {
  gr = {}
  gr.x = 0
  gr.y = 0
  gr.z = 0
  gr.size = 50
  gr.geometry = new THREE.CylinderGeometry( gr.size / 10, gr.size / 10, gr.size * 2, 6 );
  gr.material = new THREE.MeshPhongMaterial( {color: 'brown'} );
  gr.trunk = new THREE.Mesh( gr.geometry, gr.material );
  gr.trunk.position.x = gr.x
  //gr.trunk.position.y = gr.size / 2
  gr.trunk.position.z = gr.z
    
    gr.material = new THREE.MeshPhongMaterial( {color: 'green'} );
    gr.leaves = []
    var size = 25
    for (var i = 0; i < 4; i++) {if (window.CP.shouldStopExecution(4)){break;}
      gr.geometry = new THREE.ConeGeometry( size, size * 2, 10 );
      var leaf = new THREE.Mesh( gr.geometry, gr.material );
    leaf.position.x = gr.x
    leaf.position.y = 40 + (i * 10)
    leaf.position.z = gr.z
    leaf.castShadow = true;
    scene.add(leaf)
      gr.leaves.push(leaf)
      size -= 5
    }
window.CP.exitedLoop(4);

  gr.trunk.castShadow = true;
  
  scene.add( gr.trunk );
  for (var i = 0; i < gr.leaves.length; i++) {if (window.CP.shouldStopExecution(5)){break;}
    leaf = gr.leaves[i]
    //alert(leaf.position.y)
  }
window.CP.exitedLoop(5);

  return gr
}
var ornamentColors = ['lime', 'yellow', 'blue', 'white', 'red']
var ornaments = []
function newOrnament() {
  gr = {}
  gr.color = ornamentColors[randint(0, ornamentColors.length)]
  gr.geometry = new THREE.SphereGeometry( 1, 6, 6 );
  gr.material = new THREE.MeshBasicMaterial( {color: gr.color} );
  gr.mesh = new THREE.Mesh( gr.geometry, gr.material );
  scene.add( gr.mesh );
  var cont = false
  var quitlength = 0
  while (cont == false) {if (window.CP.shouldStopExecution(7)){break;}
    quitlength += 1
    var ry = randint(0, 360)
    var y =  randint(15, 60)
    var ny = 3
    gr.mesh.position.x = Math.abs((y / ny) - (25 + (10 / ny)))
    gr.mesh.position.z = 0
    point = {x: gr.mesh.position.x, y: gr.mesh.position.z}
    center = {x: 0, y: 0}
    r = rotateAround(point, center, ry)
    gr.mesh.position.x = r.x
    gr.mesh.position.z = r.y
    gr.mesh.position.y = y
    var newCont = true
    for (var i = 0; i < ornaments.length; i++) {if (window.CP.shouldStopExecution(6)){break;}
      ornament = ornaments[i]
      if (ornament.mesh.position.distanceTo(gr.mesh.position) < 3) {
        newCont = false
      }
    }
window.CP.exitedLoop(6);

    if (quitlength > 100) {
      cont = true
    } else {
      cont = newCont
    }
  }
window.CP.exitedLoop(7);

  return gr
}
for (var i = 0; i < 500; i++) {if (window.CP.shouldStopExecution(8)){break;}
  ornaments.push(newOrnament())
}
window.CP.exitedLoop(8);

var tree = newTree()
var presentColors = ['red', 'green', 'lime', 'blue', 'yellow']
var presents = []
function newPresent() {
  gr = {}
  var cont = false
  while (cont == false) {if (window.CP.shouldStopExecution(9)){break;}
  gr.color = presentColors[randint(0, presentColors.length)]
  gr.ribbonColor = presentColors[randint(0, presentColors.length)]
    if (gr.color != gr.ribbonColor) {
      cont = true
    }
  }
window.CP.exitedLoop(9);

  gr.size = randint(5, 10)
  gr.mesh = new THREE.Object3D();//create an empty container
  //present box:
  gr.geometry = new THREE.BoxGeometry( gr.size, gr.size, gr.size );
  gr.material = new THREE.MeshPhongMaterial( {color: gr.color} );
  gr.present = new THREE.Mesh( gr.geometry, gr.material );
  gr.present.castShadow = true
  gr.mesh.add( gr.present );
  //ribbons:
  gr.geometry = new THREE.BoxGeometry( 1, gr.size + 2, gr.size + 2 );
  gr.material = new THREE.MeshPhongMaterial( {color: gr.ribbonColor} );
  gr.ribbon1 = new THREE.Mesh( gr.geometry, gr.material );
  gr.ribbon1.castShadow = true
  gr.mesh.add( gr.ribbon1 );
  gr.geometry = new THREE.BoxGeometry(gr.size + 2, gr.size + 2, 1);
  gr.material = new THREE.MeshPhongMaterial( {color: gr.ribbonColor} );
  gr.ribbon2 = new THREE.Mesh( gr.geometry, gr.material );
  gr.ribbon2.castShadow = true
  gr.mesh.add( gr.ribbon2 );
  scene.add(gr.mesh)
  
  var cont = false
  var quitlength = 0
  while (cont == false) {if (window.CP.shouldStopExecution(11)){break;}
    quitlength += 1
    var x = randint(-30, 100)
    var z = randint(-30, 60)
    var y = gr.size / 2
    gr.mesh.position.x = x
    gr.mesh.position.z = z
    gr.mesh.position.y = y
    var newCont = true
    var dis = 0
    var dia = Math.sqrt(2)
    dis += (gr.size * dia)
    dis += 5
    center = new THREE.Vector3(0, gr.size / 2, 0)
    if (gr.mesh.position.distanceTo(center) < dis) {
      newCont = false
    }
    
    for (var i = 0; i < presents.length; i++) {if (window.CP.shouldStopExecution(10)){break;}
      present = presents[i]
      var dis = 0
      dis += (gr.size * dia) / 2
      dis += (present.size * dia) / 2
      if (present.mesh.position.distanceTo(gr.mesh.position) < dis) {
        newCont = false
      }
    }
window.CP.exitedLoop(10);

    if (quitlength > 100) {
      cont = true
    } else {
      cont = newCont
    }
  }
window.CP.exitedLoop(11);

  gr.mesh.rotation.y = deg(randint(0, 360))
  return gr
}
for (var i = 0; i < 20; i++) {if (window.CP.shouldStopExecution(12)){break;}
  presents.push(newPresent())
}
window.CP.exitedLoop(12);

var stockingColors = ['green', 'red', 'white']
var stockings = []
function newStocking(z) {
  gr = {}
  gr.color = stockingColors[randint(0, stockingColors.length)]
  gr.mesh = new THREE.Object3D();//create an empty container
  //main part:
  var geometry = new THREE.BoxGeometry( 10, 1, 5 );
var material = new THREE.MeshPhongMaterial( {color: gr.color} );
  gr.top = new THREE.Mesh( geometry, material );
  gr.mesh.add( gr.top );
  //heel:
  var geometry = new THREE.CylinderGeometry( 2.5, 2.5, 1, 10 );
var material = new THREE.MeshPhongMaterial( {color: gr.color} );
  gr.heel = new THREE.Mesh( geometry, material );
  gr.heel.position.x = -5
  gr.mesh.add( gr.heel );
  //foot:
  var geometry = new THREE.BoxGeometry( 5, 1, 5 );
var material = new THREE.MeshPhongMaterial( {color: gr.color} );
  gr.foot = new THREE.Mesh( geometry, material );
  gr.foot.position.x = -5
  gr.foot.position.z = 2.5
  gr.mesh.add( gr.foot );
  //heel:
  var geometry = new THREE.CylinderGeometry( 2.5, 2.5, 1, 10 );
var material = new THREE.MeshPhongMaterial( {color: gr.color} );
  gr.toe = new THREE.Mesh( geometry, material );
  gr.toe.position.x = -5
  gr.toe.position.z = 5
  gr.mesh.add( gr.toe );
  lighterScene.add(gr.mesh)
  gr.mesh.rotation.z = deg(90)
  gr.mesh.rotation.x = deg(20)
  gr.mesh.position.x = roomoffset.x - (roomsize / 2) + 21
  gr.mesh.position.y = 25
  gr.mesh.position.z = z
  var scaleFactor = 0.8
  gr.mesh.scale.x = scaleFactor
  gr.mesh.scale.z = scaleFactor
  return gr
}
for (var i = 55; i < 80; i+=10) {if (window.CP.shouldStopExecution(13)){break;}
  stockings.push(newStocking(i))
}
window.CP.exitedLoop(13);

function newSnow() {
  gr = {}
  gr.geometry = new THREE.SphereGeometry( 1, 5, 5 );
  gr.material = new THREE.MeshBasicMaterial( {color: 'white', transparent: true,opacity:0.5} );
  gr.mesh = new THREE.Mesh( gr.geometry, gr.material );
  scene.add( gr.mesh );
  gr.mesh.position.x = -(roomsize / 2) - randint(10, 50)
  gr.mesh.position.y = roomsize / 2
  gr.mesh.position.z = roomoffset.z / 2 + randint(-100, 200) - 20
  gr.dy = randint(10, 50) / 100
  gr.dz = randint(-10, 20) / 100
  return gr
}
var snow = []
var nextSnow = 0
var geometry = new THREE.OctahedronGeometry(5, 0)
var material = new THREE.MeshBasicMaterial( {color: 'yellow'} );
var star = new THREE.Mesh(geometry, material)
scene.add(star)
star.position.y = 78
var starlight;
//
    starlight = new THREE.PointLight('yellow', 0.5, 50);
starlight.position.y = 78
scene.add(starlight);
      //end of elements
			camera.position.x = 130;
      camera.position.y = 30
      camera.position.z = roomoffset.z / 2;
point = {x: camera.position.x, y: camera.position.z}
center = {x: 0, y: roomoffset.z / 2}
r = rotateAround(point, center, 45)
camera.position.x = r.x
camera.position.z = r.y
      lookAt = new THREE.Vector3( 0, 30, roomoffset.z / 2 )
      oControls.target.set(0, 30, roomoffset.z / 2);
oControls.enablePan = false;
oControls.maxPolarAngle = Math.PI * 0.55;
oControls.minAzimuthAngle = Math.PI * 0; // radians
oControls.maxAzimuthAngle = Math.PI * 0.65; // radians
oControls.minDistance = 10;
 oControls.maxDistance = 130;
oControls.update()
      //oControls.target.set(0, 10, 0);
      camera.lookAt(lookAt)

			var render = function () {
				requestAnimationFrame( render );
        mainloop()
        renderer.clear();
				renderer.render(scene, camera);
        renderer.render(lighterScene, camera);
			};
function mainloop() {
  nextSnow -= 1
  if (nextSnow < 0) {
    snow.push(newSnow())
    nextSnow = 1
  }
  snow.push(newSnow())
  for (var i = 0; i < snow.length; i++) {if (window.CP.shouldStopExecution(14)){break;}
    isnow = snow[i]
    isnow.mesh.position.y -= isnow.dy
    isnow.mesh.position.z += isnow.dz
    if (isnow.mesh.position.y < 0) {
      scene.remove(isnow.mesh)
      snow.splice(i, 1)
    }
  }
window.CP.exitedLoop(14);

  for (var i = 0; i < fire.length; i++) {if (window.CP.shouldStopExecution(15)){break;}
    ifire = fire[i]
    ifire.sphere.scale.x += ifire.scaleD
    if (ifire.sphere.scale.x > 2) {
      ifire.scaleD = -(randint(2, 15) / 1000)
    }
    if (ifire.sphere.scale.x < 1) {
      ifire.scaleD = randint(2, 15) / 1000
    }
  }
window.CP.exitedLoop(15);

  nlc -= 1
  if (nlc < 1) {
    nlc = randint(2, 5)
    intensity = randint(5, 3) / 10
    light.intensity = intensity
    firelight.intensity = intensity * 3
    lighterLight.intensity = intensity
    //lightbulb.intensity = control.roomlight / 100
  }
}
			render();
window.addEventListener( 'resize', onWindowResize, false );

function onWindowResize(){

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );

}
//# sourceURL=pen.js
</script>
</body></html>